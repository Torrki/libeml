\chapter{Event Main Loop}
\hypertarget{index}{}\label{index}\index{Event Main Loop@{Event Main Loop}}
\hypertarget{index_Introduzione}{}\doxysection{\texorpdfstring{Introduzione}{Introduzione}}\label{index_Introduzione}
Una libreria statica per l\textquotesingle{}implementazione di un sistema di main loop guidato da eventi. In un progetto multi-\/threading, un thread viene nominato come un main loop che risponde a dei comandi (eventi) generati da altri thread che hanno il main loop come riferimento per la gestione degli eventi. Ogni main loop ha una coda degli eventi associata, che raccoglie tutti i comandi che sono inviati, quando il main loop viene eseguito verifica se ci sono nuovi eventi nella coda, se si estrae quello in cima e lo elabora, altrimenti si mette in attesa; nella struttura multi-\/thread il thread del main loop viene eseguito solo quando ci sono degli eventi da elaborare, normalmente si trova in stato di sleep, viene attivato tramite una segnalazione da parte dei thread che richiedono di eseguire un comando.\hypertarget{index_Implementazione}{}\doxysubsection{\texorpdfstring{Implementazione con POSIX.}{Implementazione con POSIX.}}\label{index_Implementazione}
Trattandosi di uno sviluppo con Ubuntu, i thread usati rispettano lo standard POSIX, e dunque la segnalazione tra thread avviene tramite segnali e modalità che sono descritte nello standard. I thread che inviano comandi al main loop possono attendere per una risposta oppure continuare l\textquotesingle{}esecuzione, nel primo caso il thread chiamante si autosospende tramite sigwait, e viene risvegliato quando riceve un segnale SIGCONT, possibilmente inviato dal thread main loop. Per poter intercettare tutti i SIGCONT in maniera ordinata, i thread prima di autosospendersi modificano la propria maschera dei segnali impostando SIGCONT come un segnale da bloccare al suo arrivo, questa procedura è fatta preliminarmente per il thread main loop al momento della sua creazione in modo tale da bloccare anche i segnali SIGCONT che arrivano quando il thread è sveglio, il risultato è che il thread main loop entra in stato di sleep, tramite la funzione wait\+New\+Event, solo quando non ci sono più segnali SIGCONT accodati e la coda degli eventi è vuota.

I thread POSIX sono molto rigidi per quanto riguarda la condivisione della memoria, l\textquotesingle{}unica zona in comune in un processo multi-\/thread è lo heap, perciò tutte le funzioni che richiedono che ci sia una comunicazione diretta tra thread chiamante e main loop, come passaggio di argomenti o ottenere la risposta del main loop, devono usare delle zone di memoria che sono allocate nello heap del processo. 